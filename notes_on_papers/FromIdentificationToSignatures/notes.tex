\documentclass[12pt,twoside]{article}

% Standard Packages
\input{$THESISDIR/share/packages.tex}

% Narrow Margins
\input{$THESISDIR/share/narrow.tex}

% Macros
\input{$THESISDIR/share/macros.tex}

% Definitions
\input{$THESISDIR/share/defs.tex}

\title{NOTES ON\\ From Identification to Signatures via the Fiat-Shamir 
Transform: Minimizing Assumptions for Security and Forward-Security}
\author{Abdalla, An, Bellare and Namprempre}

\begin{document}

\maketitle

\section{Background}
\begin{itemize}

\item A {\bf canonical} id scheme $ID = (G,P,V)$ is simply a three-round, 
public-coin id scheme. In other words, a key pair $(pub,pri)$ is generated by
running $G$ on $1^n$, the prover $P_{pri}$ goes 
first and the verifier $V_{pub}$'s only message, called the {\it challenge} 
and denoted by
\textsc{Ch}, consists of his random bits. $P$'s two messages are 
called {\it committment} and {\it response}, denoted by \textsc{Cmt} 
and \textsc{Rsp}, respectively. 

The {\it completeness} property asserts that $P_{pri}$ can convince $V_{pub}$
to accept no matter what the random challenge $\textsc{Ch}$ is.

\textsc{Note}: Throughout, we assume that the public key $pub$ is part
of the private key $pri$ and that $|pub|$ uniquely determines $n$, say 
$|pub| = \ell(n) \geq n$, where $\ell^{-1}$ is a polytime
computable function. 

Also, we view $V$'s 
private coins, \textsc{Ch}, as being chosen externally, so that 
$V_{pub}(\textsc{Cmt},\textsc{Ch},\textsc{Rsp})$ is a deterministic (boolean) 
function.

\item A canonical id scheme is {\bf nontrivial} if the {\bf 
min entropy} of the committments distribution is superlogarithmic in the 
security parameter $n$. 

Recall that the min entropy of an arbitrary discrete distribution 
$D = \{p_i\}_{i=0}^{k}$ on $k$ points is defined as 
$H_{min}(D) = \log_2(1/p_{max}) = -\log_2(p_{max})$, where $p_{max} = \max\{p_i\}_{i=0}^{k}$ is the
largest probability mass. Since each $pri$ generated by $G(1^n)$ induces its 
own committments distribution $P_{pri}$ and we'd like to express the min 
entropy $H_{min}(n)$ as a function of the security parameter $n$ only, we 
compute $H(pri) = H_{min}(P(pri))$ for each $pri$ and set 
\[
H_{min}(n) = \min_{(pub,pri) \gets G(1^n)}\{H(pri)\}.
\]

In the special (but ubiquitous) case that $P_{pri}$ is uniformly distributed over
$\{0,1\}^{f(n)}$ for every $pri$, where $f: \nats \to \nats$ is some function, 
we have $p_{max} = \frac{1}{|\{0,1\}^{f(n)}|} = \frac{1}{2^{f(n)}}$ and 
$H_{min}(n) = \log_2(1/p_{max}) = \log_2(2^{f(n)}) = f(n)$. Hence
$H_{min}(n)$ is superlogarithmic in $n$ iff $f(n)$ is superlogarithmic, 
$f(n) \equiv n$ say. 
Note that if $f(n)$ is superlogarithmic in $n$, i.e. $f(n) = \omega(\log(n))$, 
then $|\{0,1\}^{f(n)}| = 2^{f(n)}$ is superpolynomial in $n$: if 
$2^{f(n)} = n^c$ for some $c$, then $f(n) = c\cdot\log(n) =
\Omega(\log(n))$, contradicting $f(n) = \omega(\log(n))$. 

We may therefore informally say that a canonical id scheme is nontrivial if 
the prover's committment space is ``large'', i.e. of size superpolynomial in 
$n$. Observe that sampling such a committment space polynomially many times is 
unlikely to yield repetitions, in the sense that the probability of getting
the same element twice is negligible in $n$ (this can be shown using the union
bound).

\item Informally, an id scheme is {\bf secure against passive attacks}, or
{\bf passively secure}, if the probability that a probabilistic polytime 
impersonator $I$ gets the verifier $V_{pub}$ to accept -- given $pub$ and 
having seen polynomially many transcripts of interactions between $V_{pub}$ 
and $P_{pri}$ -- is negligible in $n$. Here the probability is taken over all
key pairs $(pub,pri) \gets G(1^n)$.

In other words, although $I$ can {\it eavesdrop} on 
conversations between $P_{pri}$ and $V_{pub}$, he cannot attempt to extract 
information from $P_{pri}$ by interacting with it arbitrarily. 

This is a weaker notion of security than the standard {\it active} one, where 
$I_{pub}$ gets to interact with $P_{pri}$ in the role of $V_{pub}$ before 
attempting impersonation.

\item The {\bf Fiat-Shamir transform} is a way of converting a canonical id
scheme $ID = (G,P,V)$ into a signature scheme $\fs{ID}{H} = (G,
SIGN_\fanh,VER_\fanh)$ using a function $\fanh: \strs{*} \to \strs{c(n)}$ 
(or, more precisely, an ensemble $\ens{\fanh}{n}$ of such functions), 
where $c(n): \nats \to \nats$ is the length of $V$'s challenge on
security parameter $n$. 

We are mostly interested in {\it efficiently computable} $\fanh$, i.e. $\fanh$
for which there exists a deterministic Turing machine $\fanm_\fanh$ such that
$\fanm_\fanh(m) = \fanh(m)$ for all $m \in \strs{*}$. However, our definition
of $\fs{ID}{H}$ makes sense even if $\fanh$ isn't efficiently computable.

To sign a message $m \in \strs{*}$ with respect to $(pub,pri) \gets G(1^n)$, 
$SIGN_\fanh(pri,m)$ simulates $P(pri)$ to obtain a committment 
\textsc{Cmt}, deterministically computes a challenge $\textsc{Ch} = 
\fanh(\textsc{Cmt},m)$, and again simulates $P(pri,\textsc{Cmt},\textsc{Ch})$
to obtain a response $\textsc{Rsp}$. It then outputs $\sigma_m =
(\textsc{Cmt},\textsc{Rsp})$ as the signature of $m$.

To verify that $(\alpha,\gamma)$ really is the signature of $m$ with respect
to $(pub,pri)$, $VER_\fanh(pub,m,(\alpha,\gamma))$ first computes 
$\beta = \fanh(\alpha,m)$ and then outputs 1 if 
$V(pub,\alpha,\beta,\gamma) = 1$ and 0 otherwise.

Notice that the completeness property of $ID$ guarantees that, for every 
message $m$,
\[
\text{Pr}[VER_\fanh(pub,m,(\textsc{Cmt},\textsc{Rsp}))= 1] =
\text{Pr}[V(pub,\textsc{Cmt},\fanh(\textsc{Cmt},m),\textsc{Rsp}) = 1] = 1,
\]
where $SIGN_\fanh(pri,m) = (\textsc{Cmt},\textsc{Rsp})$ and the probability is
taken over $(pub,pri) \gets G(1^n)$. 

In other words, $SIGN_\fanh(pri,m)$ always outputs a legitimate signature 
(with respect to $(pub,pri)$) of $m$.

\item A few words about the {\bf Random Oracle Model} and the
{\bf Random Oracle Methodology}, both formally introduced in
\cite{bellare:rompractical}, are in order. 

Consider a cryptographic primitive $\pi_\fanh$ which makes use of a hash 
function $\fanh: \strs{*} \to \strs{c(n)}$, for example a signature scheme 
$\fs{ID}{H}$ obtained by applying the Fiat-Shamir transform (with respect to
$\fanh$) to some canonical id scheme $ID$. Our goal is to show that $\pi_\fanh$
is secure in some appropriate sense, e.g. that $\fs{ID}{H}$ is secure 
against existential forgery under chosen message attack. Since $\fanh$ is just
an efficiently computable function, we should think of our adversaries as
being given $\fanh$ as part of their input.

If $\fanh$ is a ``cryptographic hash function'', then it is assumed to be 
collision resistant in some sense (note that this implies one-wayness). The 
strongest assumption typically made is that collisions, i.e. strings 
$m_1 \neq m_2$ such that $\fanh(m_1) = \fanh(m_2)$, are infeasible to find. 
However, we would need to introduce function ensembles $\ens{\fanh}{n}$ to 
really define collision-resistance properly.

In any event, it may not be clear how to prove the security of $\pi_\fanh$
if the only assumption we make about $\fanh$ is collision-resistance of some
kind. The Random Oracle Methodology suggests that we instead model $\fanh$ as 
a random function $\rho: \strs{*} \to \strs{c(n)}$. In other words, rather 
than show that $\pi_\fanh$ is secure for any particular $\fanh$, we settle for
showing that $\pi$ is secure against adversaries which are have oracle access 
to $\rho$, where -- notionally, at least -- $\rho$ is randomly chosen from the 
set of all functions mapping $\strs{*}$ into $\strs{c(n)}$. 

Since there are infinitely many such functions, we prefer to think of $\rho$ as 
being defined incrementally: whenever the adversary asks to see $\rho(m)$ for
a new message $m \in \strs{*}$ (i.e. one the oracle hasn't been queried on
already), it will be given a randomly chosen $y \in \strs{c(n)}$; 
if the advesary subsequently quieries $\rho$ on $m$ again, it will be shown 
$y$ once more. This ensures that $\rho$ is a well-defined function and results 
in the same distribution as randomly choosing $\rho$ in advance.

Proving that $\pi$ is secure in the Random Oracle Model (which we'll
refer to as {\bf the ROM} from now on) is often much easier than showing that
$\pi_\fanh$ is secure for any particular choice of $\fanh$. However, security
in the ROM is no guarantee of ``real-world'' security, as shown in
\cite{canetti:romfails}, where Canetti et al construct a signature scheme and 
a public key encryption primitive (PKEP) secure in the ROM but not in the 
standard model. Both constructions are quite artifical -- Micali's
CS proofs, defined in \cite{micali:csproofs}, make an appearance -- and exploit 
the fact that standard-model adversaries effectively get to see the actual 
code of $\fanh$, instead of just being given oracle access to it; a similar 
idea was used by Barak in \cite{barak:nonblackbox}.

Consider the signature scheme obtained by applying the Fiat-Shamir
transform with respect to $\rho: \strs{*} \to \strs{c(n)}$ to a canonical 
id scheme $ID = (G,P,V)$, where $c(n)$ is the length of $V$'s challenge on
security parameter $n$, wholly determined by $ID$; we will denote this
signature scheme by $SIG(ID)$. Although $\rho$ isn't really a fixed function,
our meaning is hopefully clear. 

We say that $SIG(ID) = (G, SIGN, VER)$ is secure in the ROM if no probabilistic 
polytime adversary $ADV$ which is given the public key $pub$ and oracle access 
to both $SIGN_{pri}$ and $\rho$ succeeds in producing a new message 
$m \in \strs{*}$ (i.e. one $SIGN_{pri}$ hasn't been queried on), together with 
a supposed signature $\sigma$ such that $VER_{pub}(m,\sigma) = 1$, with 
probability non-negligible in the security parameter $n$. Here the probability
is taken over $(pub,pri) \gets G(1^n)$, $ADV$'s coins {\bf and the randomness 
of $\rho$}.

\end{itemize}

\section{Results}
\textsc{Note}: results regarding {\bf forward-secure signature schemes} and the 
{\bf randomized Fiat-Shamir transform} are of no relevance to us and hence have been omitted.

\bigskip\noindent
Let $ID = (G,P,V)$ be a {\bf canonical} id scheme.
\begin{enumerate}
\item $ID$ is {\bf passively secure} and {\bf nontrivial} $\Rightarrow SIG(ID)$ is {\bf secure in the ROM}

\textsc{Proof Sketch}: The proof is by a standard black-box reducibility 
argument. We show how to convert a forger $F$ which breaks the security of
$SIG(ID)$ in the ROM into an impersonator $I$ which breaks the passive
security of $ID$.

Suppose that we are given a probabilistic polytime forger $F$ which breaks the
security of $SIG(ID)$ in the ROM. $F$ is given the public key $pub$ and has 
access to both a random oracle $\fanr$ and a signing oracle $\fans$: every time 
$\fans$ is queried on a message $m' \in \strs{*}$, it outputs a signature 
$\sigma' = (\textsc{Cmt}',\textsc{Rsp}')$ of $m'$ such that 
$V_{pub}(\textsc{Cmt}',\textsc{Ch}',\textsc{Rsp}') = 1$, where 
$\textsc{Ch}' = \fanr(\textsc{Cmt}',m')$. 

The probability that $F_{pub}^{\fanr,\fans}$ eventually outputs a new message 
$m$ together with a signature $\sigma = (\textsc{Cmt},\textsc{Rsp})$ 
such that $V_{pub}(\textsc{Cmt},\textsc{Ch},\textsc{Rsp}) = 1$, where 
$\textsc{Ch} = \fanr(\textsc{Cmt},m)$, taken over $(pub,pri) \gets G(1^n)$, 
the randomness of $\fanr$ and $\fans$ and the coins of $F_{pub}^{\fanr,\fans}$,
is non-negligible in $n$. 

Notice that signing in $SIG(ID)$ is probabilistic, so it makes sense for
$F^{\fanr,\fans}_{pub}$ to query $\fans$ on the same string multiple times. 
On the other hand, there's nothing to gain from querying $\fanr$ on the same
string more than once, so we may assume (wlog) that $F^{\fanr,\fans}_{pub}$ 
does no such thing. 

We can also safely assume that $F_{pub}^{\fanr,\fans}$ queries $\fanr$ on
$(\textsc{Cmt},m)$ before outputting $m$ and $\sigma$. If it doesn't, we can
easily construct another forger, $F_{pub}^{'\fanr,\fans}$, that does: 
$F_{pub}^{'\fanr,\fans}$ simply simulates $F_{pub}^{\fanr,\fans}$ until the 
latter outputs a message $m$ and a signature $\sigma)$, then queries $\fanr$ on 
$(\textsc{Cmt},m)$ and outputs $(m,\sigma)$. This additional random oracle 
query, which we'll call the ``crucial query'', has no effect on 
$F_{pub}^{'\fanr,\fans}$'s success probability, since it does not affect the 
choice of $m$ or $\sigma$. 

We construct a probabilistic polytime impersonator $I$ which, given a public
key $pub$ and access to a transcript-generating oracle $\fant$, gets $V_{pub}$
to accept with probability non-negligible in the security parameter $n$. Here 
the probability is taken over $(pub,pri) \gets G(1^n)$, the randomness of 
$\fant$ and the coins of $I_{pub}^\fant$.

Say that the running time of $F_{pub}^{\fanr,\fans}$ is bounded above by
$n^c$, no matter what the outcome of its coin tosses is; such a $c$ exists since
$F_{pub}^{\fanr,\fans}$ is assumed to run in strict polynomial time. This
means that for any random tape, $F_{pub}^{\fanr,\fans}$ makes at most $n^c$ 
random oracle queries, which we'll number from 1 to $n^c$. 

$I_{pub}^{\fant}$ begins its simulation of $F_{pub}^{\fanr,\fans}$ by
guessing the index of the ``crucial query'': $I_{pub}^\fant$ uniformly 
selects an index $i \in \{1,\cdots,n^c\}$ and hopes that
$F_{pub}^{\fanr,\fans}$'s $i^{th}$ random oracle query is about
$\textsc{Cmt}\circ m$; since we've assumed that $F_{pub}^{\fanr,\fans}$ does 
make the crucial query at some point and that it never queries $\fanr$ on the 
same string twice, this happens with probability $\frac{1}{n^c}$. 

What does $I_{pub}^\fant$ gain by correctly guessing $i$? It learns the value 
of $\textsc{Cmt}$, which it can send to $V_{pub}$ to obtain a challenge
$\textsc{Ch}$. $I_{pub}^\fant$ can then give \textsc{Ch} to 
$F_{pub}^{\fanr,\fans}$ as the answer to the crucial query, thereby ensuring
that the message \textsc{Rsp}, which the latter eventually outputs as
part of $\sigma$, is the correct answer to \textsc{Ch}.

During the simulation, $I_{pub}^\fant$ responds to all of 
$F_{pub}^{\fanr,\fans}$'s random oracle queries but the $i^{th}$ with a 
uniformly chosen string from $\strs{c(n)}$ (recall that $F_{pub}^{\fanr,\fans}$
never queries $\fanr$ on the same string twice, by assumption); the $i^{th}$ 
query is handled specially. 

Suppose that that for its $i^{th}$ random oracle query, $F_{pub}^{\fanr,\fans}$
asks to see $\fanr(m')$ for some $m' \in \strs{*}$. $I_{pub}^{\fant}$ parses
$m'$ as $\textsc{Cmt}\circ m$, sends \textsc{Cmt} to $V_{pub}$ and receives a
challenge $\textsc{Ch} \in \strs{c(n)}$ in response. It then gives \textsc{Ch}
to $F_{pub}^{\fanr,\fans}$ as the answer to its query and continues the
simulation.

Whenever $F_{pub}^{\fanr,\fans}$ asks to see a signature of a message $m'$,
$I_{pub}^\fant$ queries $\fant$ to obtain a random transcript
$\textsc{Tr}' = (\textsc{Cmt}',\textsc{Ch}',\textsc{Rsp}')$ and then gives 
$\textsc{Tr}'$ to $F_{pub}^{\fanr,\fans}$. 

There is a problem with this approach if $F_{pub}^{\fanr,\fans}$ 
queries $\fans$ on the same message $m'$ many times, which is a reasonable
thing to do because signing in $SIG(ID)$ is probabilistic. In order for the 
resulting transcripts to be legitimate signatures of $m'$, it must be the case 
that $\fanr(\textsc{Cmt}',m') = \textsc{Ch}'$ for all of them. $\fant$, however,
generates $\textsc{Ch}'$ randomly. 

If the committments $\textsc{Cmt}'$ are distinct then $\textsc{Cmt}'\circ m'$ 
is a new message, so that $\fanr(\textsc{Cmt}',m')$ is distributed uniformly 
over $\strs{c(n)}$ and we're fine. If the committments match, on the other 
hand, then we will likely run into trouble: should the challenges 
$\textsc{Ch}'$ differ, as they almost certainly will (since they're chosen
randomly from $\strs{c(n)}$), $\fanr(\textsc{Cmt}',m')$ 
will appear to have multiple values, preventing $\fanr$ from being a
well-defined function. Therefore a new committment $\textsc{Cmt}'$ is added to
the (notional) set of ``forbidden committments'' every time $\fans$ is queried
on $m'$. In the worse case, $F_{pub}^{\fanr,\fans}$ does nothing but query
$\fans$ on some message $m'$, which means that the size of the ``forbidden
committment set'' is bounded above by $n^c$.

A similar situation can occur even if $F_{pub}^{\fanr,\fans}$ doesn't query
$\fans$ on the same message more than once. Observe that if $\textsc{Tr}' =
(\textsc{Cmt}',\textsc{Ch}',\textsc{Rsp}')$ is to be a legitimate signature of
$m'$, we must have $\fanr(\textsc{Cmt}',m') = \textsc{Ch}'$. So every $\fans$
query effectively involves an implicit $\fanr$ query. But what if $\fanr$ has
been queried on $\textsc{Cmt}'\circ m'$ already? Unless we're very lucky and
$\textsc{Ch}'$ matches the value previously assigned to
$\fanr(\textsc{Cmt}',m')$, this, too, prevents $\fanr$ from being
well-defined. Therefore a new committment $\textsc{Cmt}'$ is added to the 
``forbidden committment set'' every time $\fanr$ is queried on $x \in \strs{*}$
 -- simply parse $x$ as $\textsc{Cmt}'\circ m'$. In the worst case, 
$F_{pub}^{\fanr,\fans}$ queries $\fanr$ on as many strings 
$x_1,x_2,x_3,\ldots$, which parse as $\textsc{Cmt}_1'\circ m'$, 
$\textsc{Cmt}_2'\circ m'$, $\textsc{Cmt}_3'\circ m'$,\ldots, as possible, and 
then queries $\fans$ on $m'$. Here the size of the ``forbidden committment
set'' is bounded above by $n^c - 1$, because the signing query contributes no 
forbidden committment.

Both of these difficulties can be resolved by appealing to the nontriviality
assumption: since $ID$ is nontrivial, the probability that a randomly chosen
committment $\textsc{Cmt}'$ belongs to the ``forbidden committment set'' is 
negligible in $n$, so we can safely ignore that eventuality. 

Eventually, $F_{pub}^{\fanr,\fans}$ outputs a message $m$ together with a
supposed signature $\sigma = (\textsc{Cmt},\textsc{Rsp})$ of $m$. This only 
happens after all of its random oracle queries, and in particular the $i^{th}$, 
have been answered, which means that $V_{pub}$ has already challenged 
$I_{pub}^{\fant}$ by this point. 

$I_{pub}^{\fant}$ responds by sending \textsc{Rsp} to $V_{pub}$. What is the 
probability that $V_{pub}$ accepts? 

Since $F_{pub}^{\fanr,\fans}$ succeeds in outputting a legitimate signature
$\sigma = (\textsc{Cmt},\textsc{Rsp})$ of the message $m$ with non-negligible 
probability, there is a $d$ such that
\[ 
p(n) = \text{Pr}[V_{pub}(\textsc{Cmt},\fanr(\textsc{Cmt},m),
\textsc{Rsp}) = 1] > \frac{1}{n^d} \text { for infinitely many } n,
\] 
where the probability is taken over the coins of $F_{pub}^{\fanr,\fans}$,  
the randomness of $\fans$ -- recall that signing in $SIG(ID)$ is probabilistic
-- and the randomness of $\fanr$. 

What is the probability that $I_{pub}^{\fant}$ gets $V_{pub}$ to accept after
sending it $\textsc{Cmt}$ and $\textsc{Rsp}$, i.e. that 
$V_{pub}(\textsc{Cmt},\textsc{Ch},\textsc{Rsp}) = 1$, taken over $V_{pub}$'s 
coins (\textsc{Ch}), the randomness of the transcript oracle $\fant$ and the 
coins of $I_{pub}^\fant$? 

If $I_{pub}^\fant$ correctly guesses the index $i$ of $F_{pub}^{\fanr,\fans}$'s 
$\fanr(\textsc{Cmt},m)$ query and its simulation of $F_{pub}^{\fanr,\fans}$
is not plagued by any ``committment collision'' issues -- which only crop up
with negligible probability and can therefore be safely ignored (informally,
at least) -- then the answer is again $p(n)$. Since the guessing is
independent from the simulation, we obtain:

\[
\text{Pr}[V_{pub}(\textsc{Cmt},\textsc{Ch},\textsc{Rsp}) = 1] \approx
\frac{1}{n^c}\cdot p(n) > \frac{1}{n^c}\cdot \frac{1}{n^d} = \frac{1}{n^{c+d}}
\text{ for infinitely many } n.
\]

This shows that $I_{pub}^\fant$'s success probability is non-negligible in $n$,
so $I_{pub}^\fant$ breaks the passive security of $ID$ and we are done. 

\textsc{Remarks}: Observe that the interaction between $\fans$ and $\fanr$ -- 
namely the whole implicit queries business -- forced us to invoke the 
nontriviality assumption even in the case that $F_{pub}^{\fanr,\fans}$ did not 
query $\fans$ on the same message more than once. More precisely, we required 
{\it some} assumption strong enough to guarantee that the probability of 
landing in the forbidden commitment set when sampling the committment space is 
negligible in $n$.

However, there would be no need for this type of assumption if $F_{pub}$
were not allowed to query $\fans$ at all, which yields the following result:
\[
ID \text{ passively secure } \Rightarrow SIG(ID) \text{ passively secure in 
the ROM,} 
\]

where a signature scheme is deemed {\bf passively secure in the ROM} if it is
secure in the ROM against adversaries not allowed any $\fans$ queries; note
that ordinary ROM security implies passive ROM security. 

\item $ID$ is {\bf passively secure} $\Leftarrow SIG(ID)$ is {\bf secure in 
the ROM}

\textsc{Proof Sketch}: The proof is again by a black-box reducibility
argument. We show how to convert an impersonator that breaks the passive
security of $ID$ into a forger that breaks the security of $SIG(ID)$ in the
ROM. 

Suppose that we are given a probabilistic polytime 
impersonator $I$ that breaks the passive security of $ID$: a key pair 
$(pub,pri)$ is generated by running $G$ on $1^n$ together with random bits; 
$I$ is given the public key $pub$ and has access to a transcript-generating 
oracle $\fant$ which probabilistically simulates the interaction between 
$P_{pri}$ and $V_{pub}$ to produce a transcript \textsc{Tr} = $(\textsc{Cmt},
\textsc{Ch},\textsc{Rsp})$ every time it's queried; the probability that 
$I_{pub}^\fant$ gets $V_{pub}$ to accept after being shown a bunch of legitimate 
transcripts by $\fant$, taken over the choice of $(pub,pri)$, the randomness 
of $\fant$ and the coins of $I_{pub}^\fant$, is non-negligible in $n$.

We construct a probabilistic polytime forger $F$ which, given a public key
$pub$ and access to a random oracle $\fanr$ and a signing oracle $\fans$, 
produces a signature $\sigma_m = (\textsc{Cmt},\textsc{Rsp})$ such that 
Pr$[V_{pub}(\textsc{Cmt},\fanr(\textsc{Cmt},m),\textsc{Rsp}) = 1]$ is 
non-negligible in $n$, for any message $m \in \strs{*}$; here the probability
is taken over $(pub,pri) \gets G(1^n)$, the randomness of $\fanr$ and
$\fans$, and the coins of $F_{pub,m}^{\fanr,\fans}$. 

Given a public key $pub$ and a message $m$ to sign, $F^{\fanr,\fans}_{pub,m}$ 
simulates $I_{pub}^\fant$ as follows: whenever $I_{pub}^\fant$ queries $\fant$,
$F^{\fanr,\fans}_{pub,m}$ computes $(\textsc{Cmt}',\textsc{Rsp}') = \fans(m')$, 
$\textsc{Ch}' = \fanr(\textsc{Cmt}',m')$ and gives the transcript 
$\textsc{Tr} = (\textsc{Cmt}',\textsc{Ch}',\textsc{Rsp}')$ to $I_{pub}^\fant$. 
The choice of messages $m' \in \strs{*}$ is immaterial as long as they are 
distinct and different from $m$. We need them to be distinct so that $\fanr$ is 
queried on a new string every time, ensuring that $\fanr(\textsc{Cmt}',m')$ is 
uniformly distributed over $\strs{c(n)}$ and $\textsc{Tr}$ is distributed 
exactly like a random transcript. They should differ from $m$ because $F$ can't 
win by forging the signatures of messages it queried $\fans$ on.

Eventually, $I_{pub}^\fant$ outputs a committment $\textsc{Cmt}$ and awaits 
$V_{pub}$'s challenge. At this point, $F_{pub,m}^{\fanr,\fans}$ computes 
$\textsc{Ch} = \fanr(\textsc{Cmt},m)$ and gives $\textsc{Ch}$ to
$I_{pub}^\fant$, which responds with $\textsc{Rsp}$; notice that up till now 
$\fanr$ has only been queried on strings of the form $\textsc{Cmt}' \circ m'$, 
where $m' \neq m$, so $\textsc{Cmt}\circ m$ is a new string and 
$\fanr(\textsc{Cmt},m)$ is distributed uniformly over $\strs{c(n)}$. 
$F_{pub,m}^{\fanr,\fans}$ then outputs $\sigma = (\textsc{Cmt},\textsc{Ch},
\textsc{Rsp})$ as the signature of $m$.

The probablity that $\sigma$ is a legitimate signature of $m$ with respect to
$(pub,pri)$ is equal to the probability that $I_{pub}^\fant$ gets $V_{pub}$ to
accept, which is non-negligible by assumption. Hence $F_{pub,m}^{\fanr,\fans}$ 
breaks the security of $SIG(ID)$ in the ROM.

\textsc{Remarks}: Notice that the proof works whether $ID$ is trivial or not,
since $F_{pub,m}^{\fanr,\fans}$ can easily generate properly distributed 
transcripts by appropriately choosing the messages it queries $\fans$ and 
$\fanr$ on. This shows that the nontriviality of $ID$ is {\bf not} a necessary 
condition for the security of $SIG(ID)$ in the ROM, although the authors appear 
to claim that it is. In other words, we can't argue that $ID$ is non-trivial 
just because $SIG(ID)$ is secure in the ROM.

Hence it might be the case that the nontriviality assumption used by the
authors to prove the converse direction, i.e. that $SIG(ID)$ is secure in the
ROM if $ID$ is both passively secure and nontrivial, might be either too 
strong or unnecessary altogether.

\end{enumerate}

\section{Open Questions}
\begin{itemize}
\item What if $ID$ is actively secure, can we get rid of the nontriviality
assumption then? If so, how?

\item 
%Recall that a canonical id scheme is said to be {\bf nontrivial} if the 
%size of its committment space is superpolynomial in the security parameter $n$;
%the actual definition is more technical, but this rough approximation will do 
%for our purposes. 

Let us informally label a canonical id scheme ``hypertrivial'' if its
committment space consists of
%is of constant size, which certainly isn't superpolynomial in
%$n$. In the most pathological case, the committment space contains 
only a single message, say $\lambda$ (any fixed $m \in \strs{*}$ will do). 
%Such an id scheme is not only trivial, but spectacularly so.

Although Bellare et al appear to claim that nontriviality of $ID$ is
necessary for ROM-security of $SIG(ID)$, i.e. that {\bf every trivial passively 
secure canonical id scheme yields a signature scheme insecure in the ROM}, all they 
actually show is that, assuming that factoring certain integers is hard, 
{\bf there exists a ``hypertrivial'' passively secure id scheme which yields a 
signature scheme insecure in the ROM}. 

Might there not exist, under plausible assumptions, a passively secure 
``hypertrivial'' id scheme which {\it does} yield a ROM-secure signature 
scheme? All signs point to ``yes''; give a concrete example.  

%More intriguingly, is it possible that some other additional assumption on 
%$ID$, one strictly weaker than the nontriviality assumption, might suffice to 
%prove that passively secure id schemes yield ROM-secure signature schemes?
\end{itemize}

\bibliographystyle{alpha}
\bibliography{$THESISDIR/share/random_oracles}

\end{document}
