\documentclass[12pt,twoside]{article}

% Standard packages
\input{../../share/packages.tex}
\usepackage{nopageno}

% Formatting
\input{../../share/format.tex}

% Macros
\input{../../share/macros.tex}

% Force proofs to end in a filled-in square rather than a hollow one.
\renewcommand{\qedsymbol}{$\blacksquare$}

% A basic theorem environment
\theoremstyle{plain}
\newtheorem*{thm}{Theorem}

% A basic definition environment
\theoremstyle{definition}
\newtheorem*{defn}{Definition}

\theoremstyle{remark}
\newtheorem*{rem}{Remark}

\title{Secure canonical identification schemes yield Fiat-Shamir signature
schemes secure in the random oracle model}
\author{Victor Glazer}

\begin{document}
\maketitle
\section*{Background}
\begin{itemize}
\item An identification scheme $ID = (G,P,V)$ is said to be \emph{canonical} 
if it is a three-round, public-coin scheme. The prover $P$ goes first; his 
move is called the \emph{committment}, denoted by \textsc{Cmt}. The verifier 
$V$ replies with a random \emph{challenge} \textsc{Ch}, consisting of his 
random bits. $P$ then sends a \emph{response} \textsc{Rsp} to $V$, who either 
accepts or rejects the transcript $(\textsc{Cmt},\textsc{Ch},\textsc{Rsp})$. 
To simplify the presentation, we assume throughout that $|pri| > |pub| \geq n$
and $|\textsc{Ch}| = n$.
% This alleviates the need
%for the unary security parameter $1^n$ to be input to $P$, $V$ and other TMs
%of interest.

\item The \emph{Fiat-Shamir transform} is a method for converting canonical
identification schemes into signature schemes using hash functions. Let 
$ID = (G,P,V)$ be a canonical identification scheme and $h: \strs{*} \to 
\strs{n}$ be a hash function. $SIG_h(ID) = (GEN, SIGN, VER)$ denotes the 
following signature scheme: the key generation algorithm, $GEN$, is identical 
to $G$. To sign a message $m$, $SIGN_{pri}$ runs $P$ on $pri$
%(together with some random bits) 
to obtain a committment \textsc{Cmt} and gives $h(\textsc{Cmt},m)$ to $P$ as 
the challenge \textsc{Ch}, to which $P$ responds with \textsc{Rsp}. 
$SIGN_{pri}$ then outputs $\sigma = (\textsc{Cmt},\textsc{Rsp})$ as the 
signature of $m$. To determine whether $\sigma = (\textsc{Cmt},\textsc{Rsp})$ 
is a legitimate signature of message $m$, $VER_{pub}$ first computes 
$\textsc{Ch} = h(\textsc{Cmt},m)$ and then runs $V_{pub}$ on $(\textsc{Cmt},
\textsc{Ch},\textsc{Rsp})$, outputting whatever he outputs. 

%$SIG_\fanr(ID)$ will denote a scheme where the role of $h$ is
%played by a random oracle $\fanr: \strs{*} \to \strs{n}$.

%\begin{rem}
%$\fs{ID}{h}$
%Fiat-Shamir signature schemes 
% should strictly speaking be defined with respect to 
%a \emph{hash function ensemble} $\fanh = \ens{\fanh}{n}$ rather than a single hash function $h$. This is because one can easily 
%come up with (contrived) schemes $\fs{ID}{h}$ which are insecure even though $ID$ is secure, no matter what $h$ is.  
%For example, suppose that we force $P$ to output the private key $pri$ as the response \textsc{Rsp} whenever \textsc{Ch} = $h(\textsc{Cmt})$.  
%Since \textsc{Ch} is chosen randomly, this modification doesn't compromise the security of $ID$. However, the following forger $F$ breaks the 
%security of $\fs{ID}{h}$ for any $h$: $F$ asks to see the signature of
%the empty string $\lambda$ and is given $\sigma = (\textsc{Cmt},\textsc{Rsp})$. 
%Since $h(\textsc{Cmt},\lambda) = h(\textsc{Cmt})$ for any \textsc{Cmt}, it must be the case that
%$\textsc{Rsp} = pri$. $F$ can now correctly sign any message it likes. 

%This problem isn't hard to fix --- simply have $GEN$ randomly choose a key that
%uniquely identifies $h$ and append it to the public key $pub$. 
%The forger's success probability is now also taken over the choice of $h$,
%ruling out the sort of attack described above.
%\end{rem}

\end{itemize}

\section*{Results}

\begin{thm}
Let $ID = (G,P,V)$ be a secure canonical identification scheme.\\ 
Then 
$\fs{ID}{} = (GEN,SIGN,VER)$ is secure in the random oracle model.
\end{thm}
\begin{proof}
Let $F$ be a forger that breaks the security of $\fs{ID}{}$ in the random
oracle model; $F$ has access to a random oracle $\fanr$ and a signature oracle 
$\fans$. Denote the space $P$ draws its committments from by $\fanc \subset
\strs{*}$. We make no assumptions about $\fanc$ beyond the fact that it must 
be samplable by $P$ in time polynomial in $n$, so $\fanc = \strs{n}$ and 
$\fanc = \{\lambda\}$ are equally legitimate choices. Also, denote the message
whose signature $F$ tries to forge by $m^*$ and its supposed signature by 
$\sigma^* = (\textsc{Cmt}^*, \textsc{Rsp}^*)$.

\medskip\noindent
Let us make a few simplifying assumptions about $F$: 
\begin{enumerate}[$(i)$]
\item $F$ never queries his random oracle $\fanr$ on the same string more 
than once. 

\item All of $F$'s random oracle queries are of the form
$\fanr(\textsc{Cmt},m)$, where $\textsc{Cmt} \in \fanc$ and $m \in \strs{*}$.

\item  At some point during its execution, $F$ queries $\fanr$ on 
$(\textsc{Cmt}^*,m^*)$. This special query is called the ``crucial query''. 
%\item $F$ queries $\fans$ exactly $b(n)$ times on each distinct message, and
%these queries are contiguous (it makes sense for
%$F$ to ask for multiple signatures of the same message, since signing is
%probabilistic in
%$\fs{ID}{\fanr}$). For example, if $F$ queries $\fans$ on $n$
%distinct messages in total, then its $\fans$ queries are arranged as
%follows:
%\[
%\underbrace{\fans(m_1),\fans(m_1),\ldots,\fans(m_1)}_{b(n) \text{
%times}},\underbrace{\fans(m_2),\fans(m_2),\ldots,\fans(m_2)}_{b(n) \text{
%times}},\ldots,\underbrace{\fans(m_n),\fans(m_n),\ldots,\fans(m_n)}_{b(n) 
%\text{ times}}
%\]
%\item $F$ follows every $\fans$ query with a corresponding ``implicit'' 
%$\fanr$ query. For instance, immediately after being told 
%that $(\textsc{Cmt},\textsc{Rsp})$ is a signature of $m$, $F$
%queries $\fanr$ on $(\textsc{Cmt},m)$.
\end{enumerate}
It isn't too hard to show that if a successful forger 
exists, then there exists one satisfying the above properties. 
Suppose that $F$ fails to have property $(i)$, so that he queries $\fanr$ on 
some string $m \in \strs{*}$ multiple times. Let $F'$ be 
the same as $F$, except that the first time $\fanr$ is queried on $m$ $F'$ 
writes $ans = \fanr(m) \in \strs{n}$ down on an unused portion of his tape, 
and all subsequent $\fanr$ queries about $m$ are answered by looking $ans$ up.
Since $\fanr$ is a function, $F'$'s success probability is unchanged, 
yet he only queries $\fanr$ on $m$ once. If there is another message 
$m' \in \strs{*}$ on which $F'$ queries $\fanr$ multiple times, we can repeat 
the above process to get a new forger $F''$ which again queries $\fanr$ on 
$m'$ only once. Proceeding in this fashion, we eventually obtain a forger 
who does not query $\fanr$ on any message more than once, and whose success 
probability is identical to that of $F$.

\medskip\noindent
Now suppose that $F$ fails to have property $(ii)$, meaning that some of his 
random oracle queries are not of the form $\fanr(\textsc{Cmt},m)$ for any
committment $\textsc{Cmt} \in \fanc$ and message $m \in \strs{*}$. Let $F'$ be 
the same as $F$, except that malformed $\fanr$ queries are answered randomly 
(and independently). Since $\fanr$ also chooses his replies randomly and 
independently, $F'$'s answers have exactly the right distribution. Assumption 
$(i)$ guarantees that $F$ doesn't repeat random oracle queries, so $F'$ needn't 
write his answers down and look them up later. It is important to observe
that, in general, $\fanr$'s answers must be consistent with those of the 
signature oracle $\fans$. If $\fans(m) = (\textsc{Cmt},\textsc{Rsp})$, it 
better be the case that $V_{pub}(\textsc{Cmt},\fanr(\textsc{Cmt},m),
\textsc{Rsp}) = 1$. However, malformed random oracle queries are unaffected by 
this consistency requirement. The new forger's success probability is
therefore identical to that of $F$, and all of his $\fanr$ queries are
well-formed. 

\medskip\noindent
Finally, suppose that $F$ fails to have property $(iii)$, namely he never 
queries $\fanr$ on $(\textsc{Cmt}^*,m^*)$. Let $F'$ be a new forger which
waits for $F$ to output a message $m^*$ together with a putative
signature $\sigma^* = (\textsc{Cmt}^*,\textsc{Rsp}^*)$, queries $\fanr$ on
$(\textsc{Cmt}^*,m^*)$ and then outputs $(m^*,\sigma^*)$. $F'$ makes the 
crucial query required by assumption $(iii)$, and his success probability is 
identical to that of $F$, since the extra $\fanr$ query does not affect his 
output. It is also worth noting that our modification of $F$ doesn't violate
assumptions $(i)$ and $(ii)$, since the extra random oracle query is both of 
the right form and different from all previous $\fanr$ queries.

\medskip\noindent
We are now ready to describe an impersonator $I$ which breaks the security of 
$ID$ by simulating $F$. Recall that $I$'s goal is to get the verifier $V$ to 
accept by interacting with him in the role of the prover $P$, having first 
interacted with $P$ in the role of $V$ polynomially many times. Since $I$ is 
trying to break the \emph{active} security of $ID$, he can send $P$ whatever 
messages he likes and not just random ones.
%Throughout, we assume for
%convenience that the verifier $V$ draws his challenges \textsc{Ch} from
%$\strs{n}$.
%This leads to no loss of generality, since the security of $ID$
%implies that the size of the challenge space must be superpolynomial in $n$.

%Note that $I$ needs to somehow 
%``fake'' answers to $F$'s oracle queries. 

\medskip\noindent
Consider the experiment where a pair of keys $(pub,pri)$ is generated by
running $G$ on $1^n$ (together with some random bits), and 
$I$ is given the public key $pub$.

\medskip\noindent
Let $q_\fanr$ and $q_\fans$ denote the number of times $F$ queries $\fanr$ and 
$\fans$, respectively, and set $q = q_\fanr + q_\fans$. $I$ first interacts 
with $P_{pri}$ $q\cdot q_\fans$ times in order to construct $q$ ``transcript 
blocks'' $\fanb_1,\ldots,\fanb_q$. Each block is made up of $q_\fans$ 
transcripts of the form $(\textsc{Cmt},r,\textsc{Rsp})$, obtained as follows: 
$I$ first receives a committment $\textsc{Cmt} \in \fanc$ from $P_{pri}$. Next,
$I$ sends a challenge $r \in \strs{n}$ to $P_{pri}$. If \textsc{Cmt} does not 
appear in any of the transcripts added to the block so far, $r$ is chosen 
randomly. Otherwise, $r$ is set to the challenge associated with \textsc{Cmt}. 
$P_{pri}$ then responds with \textsc{Rsp}, and the transcript 
$(\textsc{Cmt},r,\textsc{Rsp})$ is added to the block.

\medskip\noindent
$I$ next guesses the index of $F$'s ``crucial query'' by randomly choosing
$k \in \{1,\ldots,q_\fanr\}$. 

\medskip\noindent
$I$ then begins his simulation of $F$. Note that assumption $(ii)$ above
enables us to associate a unique message $m$ with every $\fanr$ query 
$F$ makes. Since $\fans$ queries explicitly reference a message, each 
of $F$'s oracle queries therefore has a message associated with it. 
Let $m_1,\ldots,m_d$, $d \leq q$ (recall that $q$ is the total number of
oracle queries made by $F$), be the distinct messages $F$ queries his 
oracles on. $I$ answers queries associated with $m_i$, $1 \leq i \leq d$, 
using transcripts stored in block $\fanb_i$: the answer to the 
$j^{th}$ $S(m_i)$ query is $(\textsc{Cmt},\textsc{Rsp})$, 
where $(\textsc{Cmt},r,\textsc{Rsp})$ is the $j^{th}$ transcript in 
$\fanb_i$. If \textsc{Cmt} appears in any of the transcripts stored in 
$\fanb_i$, then the answer to $\fanr(\textsc{Cmt},m_i)$ is $r$, the 
challenge associated with \textsc{Cmt}. Otherwise, $\fanr(\textsc{Cmt},m_i)$ 
is answered randomly. 

\medskip\noindent
The $k^{th}$ random oracle query, $\fanr(\textsc{Cmt}',m')$, is handled 
specially (recall that $k$ is $I$'s guess at the index of $F$'s ``crucial 
query''). $I$ sends $\textsc{Cmt}'$ to $V_{pub}$, effectively ending his 
``active phase'', receives a challenge \textsc{Ch} in reply and then gives 
\textsc{Ch} to $F$ as the answer to $\fanr(\textsc{Cmt}',m')$. Let $k^*$ denote
the true index of $F$'s crucial query. Observe that if $I$'s guess is wrong, 
i.e.  $k^* \neq k$, then his simulation of $F$ may break down: what if $F$ 
requests to see some signatures of $m'$? If one of these involves
$\textsc{Cmt}'$ --- which may be very likely, depending on the committment 
distribution --- then the correct answer to $\fanr(\textsc{Cmt}',m')$ is the 
corresponding challenge, $r$, which almost certainly differs from \textsc{Ch}. 
However, if $k^* = k$ then $m'$ is the message whose signature $F$ is trying to
forge, so $\fans$ won't be queried on $m'$.  

\medskip\noindent
Eventually, $F$ outputs a message $m^*$ together with an alleged signature
$\sigma^* = (\textsc{Cmt}^*,\textsc{Rsp}^*)$ of $m^*$ (note that $m^* = m$ and 
$\textsc{Cmt}^* = \textsc{Cmt}$ if $I$ guessed $k^*$ correcty). $I$ then sends
$\textsc{Rsp}^*$ to $V_{pub}$, who either accepts or rejects the transcript
$(\textsc{Cmt},\textsc{Ch},\textsc{Rsp}^*)$.

\medskip\noindent
Let $p_F$ and $p_I$ denote the success probabilities of $F$ and $I$,
respectively. We have
\[ 
p_I = \text{Pr}[V_{pub}(\textsc{Cmt},\textsc{Ch},\textsc{Rsp}^*) = 1]
\]
%\medskip\noindent
%Observe that assumption $(ii)$ allows us to associate a message with every
%$\fanr$ query, and let $m_1,m_2,m_3,\ldots$ be the distinct messages $F$ 
%queries its oracles on.
%Denote the number of explicit $\fanr$ queries $F$ makes by $r(n)$, and let
%$s(n)$ be the number of distinct messages $F$ queries $\fans$ on. $I$ first 
%guesses the index of $F$'s ``crucial query'' by randomly choosing 
%$i \in \{1,\ldots,r(n)\}$. It then obtains $s(n)$ ``signature blocks'' 
%$b_{1},\ldots,b_{s(n)}$ by interacting with $P_{pri}$ in the role of 
%$V_{pub}$ $s(n)\cdot b(n)$ times. 
%\medskip\noindent
%Let $c(n)$ denote the length of $V$'s challenges. Each signature block 
%consists of $b(n)$ transcripts of the form $(\textsc{Cmt},r,\textsc{Rsp})$, 
%constructed as follows: $I$ receives a committment $\textsc{Cmt}$ from 
%$P_{pri}$. If \textsc{Cmt} does not occur in any of the existing transcripts, 
%$I$ randomly chooses a challenge $r \in \strs{c(n)}$ and sends it to 
%$P_{pri}$. Otherwise, $I$ resends the challenge $r$ from the 
%transcript in which \textsc{Cmt} occurs. In both cases $P_{pri}$ responds 
%with \textsc{Rsp}, and $I$ moves on to the next transcript.
%\medskip\noindent
%$I$ now begins its simulation of $F$. The first $b(n)$ $\fans$ queries and the
%corresponding implicit $\fanr$ queries are answered using transcripts 
%contained in $b_1$, the next $b(n)$ using transcripts contained in $b_2$, 
%and so on. All explicit $\fanr$ queries but the $i^{th}$ are answered
%randomly.
%Let $(pub,pri)$ be a matching pair of keys generated by running $G$ on $1^n$.
%Recall that to sign a message $m$ with respect to the private key $pri$, 
%$SIGN_{pri}^\fanr$ first
%gets a committment \textsc{Cmt} from $P_{pri}$, then queries $\fanr$ on
%$(\textsc{Cmt},m)$ to obtain a challenge $\textsc{Ch}$, and finally sends
%$\textsc{Ch}$ to $P_{pri}$, receiving $\textsc{Rsp}$ in response.  
%$SIGN_{pri}^\fanr$ then outputs $\sigma = (\textsc{Cmt},\textsc{Rsp})$ as the
%signature of $m$. The prover $P$ is in general probabilistic, so that there
%are many possible committments \textsc{Cmt} and many valid responses
%\textsc{Rsp} to a given challenge \textsc{Ch}. Consequently, a message $m$ in
%general has many legitimate signatures $\sigma$.
%To determine whether $\sigma = (\textsc{Cmt},\textsc{Rsp})$ is a legitimate 
%signature of message $m$, $VER_{pub}^\fanr$ first queries its oracle $\fanr$ 
%on 
%$(\textsc{Cmt},m)$ to obtain a challenge \textsc{Ch}, and then accepts if and
%only if $V_{pub}(\textsc{Cmt},\textsc{Ch},\textsc{Rsp})$ does.
%Let $F$ be a forger that breaks the security of $SIG_\fanr(ID)$. $F$ is 
%probabilistic has access to both a random oracle $\fanr$ and a signing oracle 
%$\fans$. Denote the running time of $F$, the number of random oracle queries 
%it 
%makes and its success probability by $t(n)$, $q(n)$ and $p(n)$, respectively.
%Here the probability is taken over the coins of $F$ and $G$, as well as the 
%randomness of $\fanr$ and $\fans$. We'll make a few simplifying assumptions 
%about $F$, wlog:
%\begin{itemize}
%\item $F$ never queries $\fanr$ on the same string more than once. 
%\item If $F$ requires multiple signatures of a message $m$, it asks for 
%them all at once.
%\item One of $F$'s $q(n)$ random oracle queries, which we refer to as the
%``crucial query'', is of the form $\fanr(\textsc{Cmt}^*,m^*)$, where $m^*$ is
%the message whose signature $F$ is trying to forge and $\sigma^* =
%(\textsc{Cmt}^*,\textsc{Rsp}^*)$ is its supposed signature.
%\end{itemize}
%We construct a probabilistic impersonator $I$ that, on input
%$pub$ \footnote{Since we are working in the uniform setting, $I$ should 
%strictly speaking be given $1^n$, the unary representation of the  security 
%parameter $n$, as well. We tacitly make the reasonable assumption that 
%$|pub| \geq n$ to get around this technical condition.}, 
%breaks the security of $ID$ by simulating $F_{pub}$. Although $I_{pub}$ does 
%not enjoy access to either $\fanr$ or $\fans$, he is allowed to see the 
%response of the honest prover $P_{pri}$ to as many arbitrary 'challenge' 
%messages as he likes before attempting to get $V_{pub}$ to accept. However, 
%once $I_{pub}$ ends his 'active phase' by sending a committment 
%$\textsc{Cmt}'$ to $V_{pub}$ and receiving a challenge $\textsc{Ch}'$ in 
%reply, he can no longer interact with $P_{pri}$. 
%First, $I_{pub}$ interacts with $P_{pri}$ as follows:
%\begin{enumerate}
%\item $I_{pub}$ receives a committment $\textsc{Cmt}$ from $P_{pri}$.
%\item If $I_{pub}$ hasn't seen \textsc{Cmt} before, it randomly chooses a 
%challenge $\textsc{Ch} \in \strs{n}$ \footnote{Here the assumption is that 
%$V$ draws its challenges from $\strs{n}$. Although that need not be the case 
%in general, the challenge space is $\strs{p(n)}$ for some poly $p(\cdot)$, 
%since $V$ runs in polynomial time. We need only replace $n$ with $p(n)$ to fix up the proof.} and 
%sends it to $P_{pri}$. Otherwise, $I_{pub}$ sends $P_{pri}$ the challenge it 
%previously sent in response to \textsc{Cmt}.
%\item $I_{pub}$ receives a response \textsc{Rsp} from $P_{pri}$. 
%\end{enumerate}
%$I_{pub}$ repeats the above three steps $t(n)$ times to obtain
%$\Psi_1 = \{\psi^i_1\}_{i=1}^{t(n)}$, where $\psi^i_1 = (\textsc{Cmt}^i_1,
%\textsc{Ch}^i_1,\textsc{Rsp}^i_1)$, and then repeats the entire process $t(n)
%-1$ times to obtain $\Psi_2,\ldots,\Psi_{t(n)}$. $I_{pub}$ interacts with $P_{pri}$ 
%$t(n)^2$ times in total.
%Next, $I_{pub}$ guesses the index of the ``crucial query'' by randomly 
%choosing 
%$ind \in \{1,2,\ldots,q(n)\}$.
%$I_{pub}$ now simulates $F_{pub}$. He answers $F_{pub}$'s oracle queries --- except for 
%the ``crucial query'', $\fanr(\textsc{Cmt}^*,m^*)$ --- using the ``canned responses'' 
%$\Psi_1,\ldots,\Psi_{t(n)}$. All queries pertaining to $m_i \in \strs{*}$, the $i^{th}$ 
%distinct message $F_{pub}$ queries its oracles on, are answered using 
%responses 
%from a single ``block'' $\Psi_i$.  
%We'll describe how $\fans$ and $\fanr$ queries are handled separately.
%Whenever $F_{pub}$ queries $\fanr$ on a string $s \in \strs{*}$, $I_{pub}$
%parses $s$ as $(\textsc{Cmt},m)$. If $m$ is a ``new'' message, i.e. neither
%$\fanr$ nor $\fans$ has previously been queried on it, then it gets assigned
%the next avilable block $\Psi_i$.
%Every time $F_{pri}$ queries one of its oracles on a string 
%$s \in \strs{*}$, $I_{pub}$ parses $s$ as $(\textsc{Cmt},m)$, a committment followed by a
%message.
\end{proof}

\end{document}

